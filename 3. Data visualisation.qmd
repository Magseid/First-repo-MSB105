---
title: "R for data science"
format: html
editor: visual
---

# 3.1 Introduction

```{r}
#| label: setup
library(tidyverse)
```

# 3.2 First steps

```{r}
mpg
```

```{r}
ggplot(data = mpg)+
  geom_point(mapping = aes(x = displ, y = hwy))
```

# 3.3 Aesthetic mappings

```{r}
# utvider ggplott til å inkludere en til variabel "color"
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

```{r}
# kan også endre "color" til "size" eller bruke begge
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class, color = class))
# kan også bruke "alpha" for å endre på gjennomsiktigheten, eller "shape" for å endre form på punktene
# ved bruk av "shape" vil den som standard kun bruke 6 forskjellige former for å definer variabler, altså vil en av 
# variablene i dette plottet ikke bli definert fordi vi har 7 variabler
```

```{r}
# kan også legge til farge manuelt
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy),color = "blue")
```

# 3.5 Facets

```{r}
# legger til "facet" for å vis flere variabler i ulike plot
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```

```{r}
# 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```

# Exercises

```{r}
# 1. What happens if you facet on a continuous variable?
# Om man bruker en kontinuerlig variable i en facet, vil du få ett panel per unike tallverdi -> ofte veldig mange paneler som blir uoversiktelig. Faceting er egentlig ment for kategoriske variabler som i dette tilfelle feks er "cyl, drv og class"
```

```{r}
# 2. What do the empty cells in plot with facet_grid(drv ~ cyl) mean? How do they relate to this plot?

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = drv, y = cyl))

# De tomme cellene er kombinasjoner av "drv" og "cyl" som ikke finnes i datasettet.
# Faceit_grid lager et rutenett av alla mulige kobinasjoner, selv om noen er tomme.

ggplot(data = mpg) +
  geom_point(mapping = aes(x = drv, y = cyl)) +
  facet_grid(drv ~ cyl)

```

```{r}
## 3. What plots does the following code make? What does . do?
# ggplot(data = mpg) + 
#   geom_point(mapping = aes(x = displ, y = hwy)) +
#   facet_grid(drv ~ .)

# ggplot(data = mpg) + 
#   geom_point(mapping = aes(x = displ, y = hwy)) +
#   facet_grid(. ~ cyl)

# "." betyr "ingen faceting" på denne aksen. altså sier den første koden at vi skal ha egne rader for hver "drv", og for den andre koden vil vi ha egne kolonner for hver "cyl"  


ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)   # rader = drv, ingen kolonner

ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)   # kolonner = cyl, ingen rader

```

```{r}
## 4. Take the first faceted plot in this section:
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
## What are the advantages to using faceting instead of the colour aesthetic? What are the disadvantages? How might the balance change if you had a larger dataset?

# Fordeler med å bruke facet er at det blir lettere å sammenligne mønstre innen hver kategori, mindre visuell støy.
# Ulemper er at det blir vanskeligere å sammanligne mellom kategoriene. 
# Med større datasett kan faceting bli mer nyttig (unngår kaos av mange farger) .
```

```{r}
## 5. Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? Why doesn’t facet_grid() have nrow and ncol arguments?
#  "nrow" og "ncol" kontrolerer hvor mange kolonner og rader som skal med i faceten.
#  facet_grid har ikke "ncol" og "nrow" fordi den alltif viser alle mulige kombinasjoner av to variabler i et fast rutenett.
```

```{r}
## 6. Hvorfor bør du sette variabelen med flest unike nivåer i kolonner i facet_grid()? 
# Skjermer er ofte bredere enn høye → bedre utnyttelse av plassen hvis du legger mange paneler bortover (i kolonner) i stedet for nedover.
```

## 3.6 Geometric objects

```{r}
# Geom er et objekt som et plott bruker for å presentere data. Man beskriver ofte et plot ut ifra hvilken type geom som blir brukt. f.eks vil en "line chart" bli kalt for et "line plot" og et "boxplot" vil bli kalt for "boxplot geom"

# nr.1 -> bruker geom_point
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

# nr.2  -> bruker geom_smooth
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))

```

```{r}
# en hver geom funksjon har en "mapping" funksjon, men ikke alle "aesthetic fungerer med alle geom. altså kan man endre fassong på et punkt, men ikke på en linje. Men på den andre siden så kan man sette en linjetype til en linje. 
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))
```

```{r}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
              
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
    
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = TRUE
  )
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE
  )
```

```{r}
# Legger til flere geoms i samme plot
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

```{r}
# Kan redusere koden når vi har gjentagende koder som den vi har over. dette kan være problematisk dersom vi ønsker å endre x-aksen til f.eks. "cty" istedenfor "hwy" fordi da må vi endre dette på 2 steder i koden, og dette kan raskt bli glemt.
# Vi kan rydde opp i dette ved å sette "mapping" funksjonen inn i ggplot()
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

```{r}
# Hvis du legger mapping inni en geom-funksjon, vil ggplot2 behandle det som lokal mapping for det laget. Denne mappingen brukes til å utvide eller overskrive den globale mappingen, men bare for det laget. På den måten kan man vise ulike aestetics i forskjellige lag.
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(mapping = aes(color = class)) +
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)

# (data = filter(mpg, class == "subcompact") betyr at smooth-linjen bare beregnes for subcompact-biler
# se = FALSE fjerner "skyggen" rundt linjen
```

# Exercises

```{r}
## 1. What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?
# line chart = geom_line()
# boxplot = geom_boxplot()
# histogram = geom_histogram()
# area chart = geom_area()
```

```{r}
# 2. Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

```{r}
## 3. What does show.legend = FALSE do? What happens if you remove it? why do you think I used it earlier in the chapter?
# show.legend = FALSE brukes i geom_*()-funksjoner for å hindre at et lag dukker opp i legenden.
```

```{r}
## 4. What does the "se" argument to geom_smooth() do?
# se bestemmer om ggplot skal vise konfidensintervallet (usikkerhetsbåndet) rundt den glatte linjen. altså bestemmer om linjen skal ha en "skygge"

```

```{r}
# 5. Will these two graphs look different? Why/why not?
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))

# Det første plottet setter data og mapping globalt i ggplot(). Det betyr at både punktene og           smooth-linjen arver dette automatisk.

# Det andre plottet starter med et tomt ggplot(), og så legges data og mapping lokalt inn i hvert lag   (geom_point() og geom_smooth()).

# Resultatet blir identisk, fordi begge lag i andre koden har fått samme data og mapping som det        første.
```

![](images/clipboard-1313578573.png){width="416"}

```{r}
## 6. Recreate the R code necessary to generate the following graphs.

# 1
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() +
  geom_smooth(se = FALSE)

# 2
ggplot() +
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy, group = drv), se = FALSE)

# 3
ggplot() +
  geom_point(data = mpg, mapping = aes( x = displ, y = hwy, color = drv)) +
  geom_smooth(data = mpg, mapping = aes( x = displ, y = hwy, color = drv),se = FALSE)

# 4
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(data = mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_smooth(se = FALSE)

# 5
ggplot() +
  geom_point(data = mpg, mapping = aes( x = displ, y = hwy, color = drv)) +
  geom_smooth(data = mpg, mapping = aes( x = displ, y = hwy, linetype = drv), se = FALSE)

# 6
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, fill = drv)) +
  geom_point(shape = 21, color = "white", size = 3, stroke = 1)
```

## 3.7 Statistical transformations

```{r}
diamonds
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
# Dan lage samme plotet som over ved å bruke "stat_count"
ggplot(data = diamonds) +
  stat_count(mapping = aes(x = cut))
# Dette fungerer fordig en hver geom har en dafault stat; og en hver stat har en default geom
# Derfor kan man vanligvis bruke geoms uten å tenke over      de underliggende statistiske                transformasjonen, men det er tre grunner til at man kanskje trenger å bruke en stat eksplisitt


# 1. Du kan noen ganger ønske å overstyre standard-statistikken. I eksemplet under endres stat i          geom_bar() fra count (standard) til identity. Da kan høyden på søylene bestemmes direkte av           verdiene i en y-variabel. Når folk snakker om stolpediagrammer, kan de enten mene denne typen         (høyden finnes allerede i dataene) eller den vanlige varianten der høyden beregnes ved å telle        rader.

demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)
ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")

# 2. Du kan noen ganger ønske å overstyre standardkoblingen fra transformerte variabler til estetikk.     For eksempel kan du ville vise et stolpediagram med proporsjoner i stedet for antall.

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))

# 3. Du kan ønske å rette mer oppmerksomhet mot den statistiske transformasjonen i koden. For eksempel     kan du bruke stat_summary(), som oppsummerer y-verdiene for hver unik x-verdi, for å tydeliggjøre     hvilken oppsummering du beregner.

ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )
```

# Exercises

```{r}
## 1. What is the default geom associated with stat_summary()? How could you rewrite the previous plot     to use that geom function instead of the stat function?
# Skriver inn ?stat_summary i consolen for å finne hjelpe siden. Der står det art geomet til              stat_summary() = pointrange

```

```{r}
## 2. What does geom_col() do? How is it different to geom_bar()?
# geom_bar() bruker stat = "count" som teller antall observasjoner i hver kategori av x. du trenger       ikke å gi en y-variabel, fordi ggplot2 regner ut høyden sev, altså "count"
# geom_col() bruker stat = "identity". Altså er det forventet at du har y-verdier i datasettet, og        bruker dem direkte som søylehøyder. Du må derfor definer både x og y.

# geom_bar() = teller antall rader per kategori automatisk.
# geom_col() = bruker de verdiene du selv gir som høyde.
```

```{r}
## 3. Most geoms and stats come in pairs that are almost always used in concert. Read through the documentation and make a list of all the pairs. What do they have in common?

# Dette er de vanligste geom-stat-parene i ggplot2. De deler samme underliggende beregning; bare navnet du kaller     er ulikt.
# 
# geom_bar() ↔ stat_count()

# geom_col() ↔ stat_identity()

# geom_histogram(), geom_freqpoly() ↔ stat_bin()

# geom_density() ↔ stat_density()

# geom_smooth() ↔ stat_smooth()

# geom_boxplot() ↔ stat_boxplot()

# geom_violin() ↔ stat_ydensity()

# geom_bin2d() ↔ stat_bin_2d()

# geom_hex() ↔ stat_binhex() (krever hexbin)

# geom_contour() ↔ stat_contour()

# geom_density_2d() / _filled ↔ stat_density_2d() / _filled

# geom_function() ↔ stat_function()

# geom_qq() ↔ stat_qq()

# geom_qq_line() ↔ stat_qq_line()

# stat_summary() ↔ (default geom_pointrange(); kan også bruke geom="point"/"line"/"errorbar")

# stat_summary_bin() ↔ typisk geom="pointrange"/"errorbar"

# geom_dotplot() ↔ stat_bindot()

# geom_count() ↔ stat_sum()

# stat_ecdf() ↔ (default geom_step())

```

```{r}
## 4. What variables does stat_smooth() compute? What parameters control its behaviour?

# 

```


```{r}
## 5. In our proportion bar chart, we need to set group = 1. Why? In other words what is the problem with these two graphs?

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = after_stat(prop)))

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))

# Uten group = 1 vil ggplot regne proporsjoner innenfor hver undergruppe (f.eks. per fill eller color). Da blir       søylehøydene feil, fordi de summerer til 1 innenfor hver kategori i stedet for over hele datasettet.

ggplot(diamonds) +
  geom_bar(aes(x = cut, y = after_stat(prop), group = 1))
# Dette tvinger ggplot til å beregne proporsjonene som én gruppe totalt.
```

## 3.8 Position adjustments

```{r}
# kan legge til farger i vår "bar chart" ved å bruke "color" eller enda mer nyttig "fill"

ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, color = cut))

ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, fill = cut))

# Setter fill til noe annet enn cut, f.eks. clarity

ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, fill = clarity))

# 
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")

# position = "fill" fungerer som stacking, men gjør at hver gruppe av stablede søyler får samme høyde. Dette gjør     det enklere å sammenligne proporsjoner mellom grupper.

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")

# Ved å bruke "position = "dodge"" kan vi plassere overlappende objekter ved siden av hverandre. Noe som gjør det     enklere å sammenligne individuelle variabler

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

```{r}
# det er en siste type adjustments som ikke er verdiful for bar charts, men som kan være veldig verdifull for         scatterplots. f.eks. i det første scatterplottet har vi kun 126 punkter selv om det er 234 observasjoner i        datasettet. Dette er fordi at verdien av variablene hwy og displ blir rundet slik at de kan bli plassert i        plotet. dette fører til "overplotting"

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

# Vi kan ungå dette ved å sette en position adjustment til "jitter". position = jitter. 

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```

# Exercises

```{r}
## 1. What is the problem with this plot? How could you improve it?
# Problemet er at cty og hwy er sterkt korrelert, så plottet gir lite ny innsikt. Du kan forbedre      det ved å velge mer meningsfulle variabler, bruke farge/form for ekstra dimensjoner, legge til     trendlinje eller redusere overlapp med alpha/jitter.
 
ggplot(data = mpg, mapping = aes(x = cty, y = hwy, color = class)) +
  geom_jitter(alpha = 0.5)
```


```{r}
## 2. What parameters to geom_jitter() control the amount of jittering?
# Geom_jitter() er en shortcut for geom_point(position = "jitter")
# - width -> hvor mye det "jitter" på x-aksen.
# - height -> hvor mye "jitter" på y-aksen.
# - seed -> Tilfeldig seed for å gjøre "jitteren" reproduserbar.

# Small jitter on x only
ggplot(mpg, aes(class, hwy)) +
  geom_jitter(width = 0.2, height = 0)

# Larger jitter on both axes
ggplot(mpg, aes(cty, hwy)) +
  geom_jitter(width = 0.5, height = 0.5, alpha = 0.5)

```


```{r}
## 3. Compare and contrast geom_jitter() with geom_count().

# geom_jitter()
# - Legger til tilfeldig støy (jitter) i posisjonen til punktene.
# - Hindrer at punkter med identiske (x, y)-verdier havner oppå hverandre.
# - Nyttig for diskrete x-verdier (f.eks. kategorier) hvor punktene ellers ville ligget som en rett       linje.
# - Ulempe: punktene vises på litt «feil» sted, kan gi inntrykk av variasjon som egentlig ikke           finnes.

ggplot(mpg, aes(cty, hwy)) +
  geom_jitter(width = 0.2, height = 0)

 
# geom_count()
# - Øker størrelsen på punktet avhengig av hvor mange observasjoner som deler samme (x,                  y)-posisjon.
# - Flytter ikke punktene – de beholdes på nøyaktig posisjon.
# - Nyttig når man har eksakte duplikater (samme verdi på x og y).
# - Ulempe: fungerer ikke hvis dataene ikke har helt like (x, y)-verdier.

ggplot(mpg, aes(cty, hwy)) +
  geom_count()

```


```{r}
## 4. What’s the default position adjustment for geom_boxplot()? Create a visualisation of the mpg         dataset that demonstrates it.

ggplot(data = mpg, mapping = aes(x = class, y = hwy, fill = drv)) + 
  geom_boxplot()
```

## 3.9 Coordinate systems

```{r}
# kan bruke coord_flip() for å bytte om på x og y aksene. Dete kan være nyttig dersom du vil ha et    horisontalt boxplot, men det kan også være nyttig dersom navnene på x eller y aksen er for lange    til å få plass
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot()
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot() +
  coord_flip()
```

```{r}
# coord_quickmap brukes for å sete den riktige aspect ratioen for kart
nz <- map_data("nz")

ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")

ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  coord_quickmap()
```

```{r}
# coor_polar()
bar <- ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = cut, fill = cut), 
    show.legend = FALSE,
    width = 1
  ) + 
  theme(aspect.ratio = 1) +
  labs(x = NULL, y = NULL)

bar + coord_flip()
bar + coord_polar()
```


# Exercises

```{r}
## 1. Turn a stacked bar chart into a pie chart using coord_polar().

ggplot(data = diamonds) +
         geom_bar(
           mapping = aes(x = cut, fill = cut),
           show.legend = FALSE
         ) +
  theme(aspect.ratio = 1) +
  labs(x = NULL, y = NULL)

bar + coord_polar()
bar + coord_flip()
```

```{r}
## 2. What does labs() do? Read the documentation.
# labs() brukes til å sette titler, aksetekster, undertitler og caption i et ggplot.

ggplot(data = mpg,mapping = aes(x = displ,y = hwy)) +
  geom_point() +
  labs(
    title = "Motorstorrelse vs. drivstofforbruk",
    x = "Motorstorrelse (liter)",
    y = "Highway MPG",
    caption = "Kilde: mpg-datasettet"
  )
```

```{r}
## 3. What’s the difference between coord_quickmap() and coord_map()?
# coord_map() projiserer en del av jorda, som er omtrent sfærisk, over på et flatt         2D-plan ved å bruke en hvilken som helst projeksjon definert i mapproj-pakken.         Kartprojeksjoner bevarer som regel ikke rette linjer, så dette krever en del           beregning. coord_quickmap() er en rask tilnærming som bevarer rette linjer. Den        fungerer best for mindre områder nær ekvator.
library(ggplot2)
library(maps)

# Hent kartdata (verdenskart)
world <- map_data("world")

# coord_quickmap(): rask tilnærming
p1 <- ggplot(world, aes(long, lat, group = group)) +
  geom_polygon(fill = "lightblue", color = "white") +
  coord_quickmap() +
  ggtitle("coord_quickmap()")

# coord_map(): ordentlig projeksjon (her Mercator)
p2 <- ggplot(world, aes(long, lat, group = group)) +
  geom_polygon(fill = "lightblue", color = "white") +
  coord_map("mercator") +
  ggtitle("coord_map('mercator')")

p1
p2

```

```{r}
## 4. What does the plot below tell you about the relationship between city and highway         mpg? Why is coord_fixed() important? What does geom_abline() do?

ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_point() + 
  geom_abline() +
  coord_fixed()

# Hva plottet viser: En klar lineær sammenheng: biler som bruker lite drivstoff i byen     (cty)          bruker også lite på motorvei (hwy). Men hwy er nesten alltid høyere enn cty      (punktene ligger     over linjen).

# geom_abline(): Tegner en diagonal linje (her med standard slope = 1 og intercept =       0). Linja      representerer hvor punktene ville ligget hvis hwy == cty.

# coord_fixed(): Setter samme skala på x- og y-aksen (1 enhet på x = 1 enhet på y).        Dette gjør     at diagonalen faktisk representerer likhet, uten at aksene blir strukket     ulikt.
```

## 3.10 The layerd grammar of graphics

```{r}
## et "template" for hvordan et ggplot kan se ut. 
# ggplot(data = <DATA>) + 
#    <GEOM_FUNCTION>(
#     mapping = aes(<MAPPINGS>),
#    stat = <STAT>, 
#    position = <POSITION>
# ) +
#  <COORDINATE_FUNCTION> +
#  <FACET_FUNCTION>
```

























